# iNeptune

### [ 대학교 연합 동아리 UMC - Neptune 지부 ]
**이 저장소는 부경대학교 iOS 꿈나무들의 스터디 기록을 담고 있습니다.**

![IMG_3695](https://github.com/iNeptune-Code-Adventurers/iNeptune/assets/118424182/59c669e6-d4bb-4d3b-9135-52976a02c5e4)

<br>

---

<br>

# 폴더구조
    - 라파:심범수
      - 1주차
        - 위클리 미션
          - 프로젝트
        - 스터디 미션
          - 프로젝트
          
          .
          .
          .
          
      - 10주차
        - 위클리 미션
          - 프로젝트
        - 스터디 미션
          - 프로젝트

<br>

---

<br>

# 목차
- [1주차](#1주차)
- [2주차](#2주차)
- [3주차](#3주차)
- [4주차](#4주차)
- [5주차](#5주차)
- [6주차](#6주차)
- [7주차](#7주차)
- [8주차](#8주차)
- [9주차](#9주차)
- [10주차](#10주차)

### Code Convention
- [Swift Style Guide](#Swift-Style-Guide)
  - [Code Formatting](#Code-Formatting)
  - [Naming](#Naming)
  - [Code Style](#Code-Style)
 
<br>

---

<br>


# 1주차

> **라파** 미션 결과물
> 
![Simulator Screen Recording - iPhone 15 Pro - 2023-09-28 at 00 22 26](https://github.com/iNeptune-Code-Adventurers/iNeptune/assets/118424182/2027328f-0549-4d86-90a7-4cd4dc6ba892)
![Simulator Screen Recording - iPhone 15 Pro - 2023-09-28 at 00 29 16](https://github.com/iNeptune-Code-Adventurers/iNeptune/assets/118424182/0c42a0e4-7fb8-45e7-968f-d2077699a730)

### 회고록
> ## 배운 점
> 라파: UICollectionView와 UICollectionViewCompositionalLayout을 사용하여 복잡한 레이아웃을 구성하는 방법, UIRefreshControl을 사용하여 새로고침 기능을 구현하는 방법, UICollectionViewCell의 각 아이템에 그림자 효과를 주는 방법과 SafeAreaBrush라는 오픈소스라이브러리를 import해서 SafeArea 영역을 보다 쉽게 색상을 채우는 방법을 배웠다.
>
> 레오: UIButton의 configuration을 사용해 버튼의 레이아웃을 잡는 방법을 익혔다.
>
> 후니: 기본적인 Xcode 단축키부터 스토리보드 기본적인 사용법, 옵셔널 기본 내용을 배웠다.

> ## 잘한 점
> 라파: 코드 베이스로 개발을 하니 코드 구조에 대해 예전보다 더욱 신경쓰게 되었고 전보다 코드 구조가 명확하게 분리되어 있으며 각 섹션에 대한 레이아웃을 별도의 메서드로 분리하여 가독성을 높이려고 노력하였습니다. 또, 이번 프로젝트의 네비게이션 바와 검색 버튼과 같은 디자인은 처음 구현해봤는데 예상보다 잘 구현되었다.
> 
> 레오: 첫 프로젝트 이후 다시 개발을 했는데 레이아웃 잡는게 생각보다 잘 돼서 성장한 걸 느꼈다. 
> 
> 후니: 내가 잘한 점보다는 라파와 레오가 적극적으로 도와줘서 너무 고마웠다.

> ## 아쉬운 점
> 라파: 코드 베이스로 레이아웃을 구성하는 것이 어려워 완벽하게 구현하지 못한 점과 탭 바의 가운데 버튼이 기기 크기가 달라지면서 위치를 벗어나는 것이 아쉬웠다.
> 
> 레오: 배달의 민족 메인화면이 엄청 어려웠다. 탭바도 커스텀해야되고, UIView의 border에 gradient주기, 디바이스 별 fontsize 대응 등 해결하지 못한 문제가 많아서 시간이 날 때 계속 고쳐봐야겠다.
> 
> 후니: 내가 공부해야할 양이 너무 많이 남아있다는 것

> ## 앞으로의 계획
> 라파: 코드 리팩토링을 통해 중복되는 코드를 최대한 줄일 것이고 디바이스 크기에 대한 레이아웃 처리를 조금 더 신경써서 코드를 짜야겠다.
> 
> 레오: 트러블 슈팅도 해당 주차 내로 완성하는걸 목표로 해야겠다. 데드라인 안에 구현을 다 할 수 있도록 계획을 꼼꼼히 세워야겠다.
> 
> 후니: 꾸준히 그리고 열심히 공부해야겠다. 그래서 라파와 레오가 추천해주는 것들과 swift 문법과 스코클을 열심히 들어야겠다.

<br>

[목차로 이동 🔺](#목차)

<br>

# 2주차

> **라파** 미션 결과물
>
*라파 위클리 미션 누락됨*
![Simulator Screen Recording - iPhone 15 Pro - 2023-10-13 at 10 25 41](https://github.com/iNeptune-Code-Adventurers/iNeptune/assets/118424182/901cd89e-dd48-4b5f-b6c7-31292558a785)

### 회고록
> ## 배운 점
> 라파: 
>
> 레오: 
>
> 후니: 

> ## 잘한 점
> 라파: 
> 
> 레오: 
> 
> 후니: 

> ## 아쉬운 점
> 라파: 
> 
> 레오: 
> 
> 후니: 

> ## 앞으로의 계획
> 라파: 
> 
> 레오: 
> 
> 후니: 

<br>

[목차로 이동 🔺](#목차)

<br>

# 3주차
> **라파** 미션 결과물
>
![Simulator Screen Recording - iPhone 15 Pro - 2023-10-13 at 23 24 02](https://github.com/iNeptune-Code-Adventurers/iNeptune/assets/118424182/9784b39e-631d-4c72-bc8f-2f8d28270c21)
![Simulator Screen Recording - iPhone 15 Pro - 2023-10-13 at 10 27 28](https://github.com/iNeptune-Code-Adventurers/iNeptune/assets/118424182/bf5d6aeb-1819-40c5-9170-e827bfc2d3a5)

### 회고록
> ## 배운 점
> 라파: scrollViewDidScroll 메서드를 사용하여 스트레치 헤더 뷰의 높이와 위치를 동적으로 조절하는 것과 UILabel을 상속받는 PaddingLabel이라는 커스텀 클래스를 정의하여 레이블을 커스텀하는 방법을 배웠다.
>
> 레오: 
>
> 후니: 

> ## 잘한 점
> 라파: ```case IndexPath(row: 0, section: 0): ``` IndexPath에 row와 section이라는 연관값을 추가하여 각 셀에 해당하는 데이터가 전달되도록 작성했다.
> 
> 레오: 
> 
> 후니: 

> ## 아쉬운 점
> 라파: 3주차에서 가장 중요한 핵심인 데이터를 다른 뷰 컨트롤러에 전달하는 것을 구현하지 못해 아쉽다.
> 
> 레오: 
> 
> 후니: 

> ## 앞으로의 계획
> 라파: 모든 스터디가 마무리되면 1주차부터 10주차까지 진행했던 프로젝트들 중 완성하지 못한 프로젝트에 대해 완성할 것이다.
> 
> 레오: 
> 
> 후니: 

<br>

[목차로 이동 🔺](#목차)

<br>

# 4주차
- 위클리 미션 실행화면 영상 업로드
- 스터디 미션 실행화면 영상 업로드

### 회고록
> ## 배운 점
> 라파: 
>
> 레오: 
>
> 후니: 

> ## 잘한 점
> 라파: 
> 
> 레오: 
> 
> 후니: 

> ## 아쉬운 점
> 라파: 
> 
> 레오: 
> 
> 후니: 

> ## 앞으로의 계획
> 라파: 
> 
> 레오: 
> 
> 후니: 

<br>

[목차로 이동 🔺](#목차)

<br>

# 5주차
- 위클리 미션 실행화면 영상 업로드
- 스터디 미션 실행화면 영상 업로드

### 회고록
> ## 배운 점
> 라파: 
>
> 레오: 
>
> 후니: 

> ## 잘한 점
> 라파: 
> 
> 레오: 
> 
> 후니: 

> ## 아쉬운 점
> 라파: 
> 
> 레오: 
> 
> 후니: 

> ## 앞으로의 계획
> 라파: 
> 
> 레오: 
> 
> 후니: 

<br>

[목차로 이동 🔺](#목차)

<br>

# 6주차
- 위클리 미션 실행화면 영상 업로드
- 스터디 미션 실행화면 영상 업로드

### 회고록
> ## 배운 점
> 라파: 
>
> 레오: 
>
> 후니: 

> ## 잘한 점
> 라파: 
> 
> 레오: 
> 
> 후니: 

> ## 아쉬운 점
> 라파: 
> 
> 레오: 
> 
> 후니: 

> ## 앞으로의 계획
> 라파: 
> 
> 레오: 
> 
> 후니: 

<br>

[목차로 이동 🔺](#목차)

<br>

# 7주차
- 위클리 미션 실행화면 영상 업로드
- 스터디 미션 실행화면 영상 업로드

### 회고록
> ## 배운 점
> 라파: 
>
> 레오: 
>
> 후니: 

> ## 잘한 점
> 라파: 
> 
> 레오: 
> 
> 후니: 

> ## 아쉬운 점
> 라파: 
> 
> 레오: 
> 
> 후니: 

> ## 앞으로의 계획
> 라파: 
> 
> 레오: 
> 
> 후니: 

<br>

[목차로 이동 🔺](#목차)

<br>

# 8주차
- 위클리 미션 실행화면 영상 업로드
- 스터디 미션 실행화면 영상 업로드

### 회고록
> ## 배운 점
> 라파: 
>
> 레오: 
>
> 후니: 

> ## 잘한 점
> 라파: 
> 
> 레오: 
> 
> 후니: 

> ## 아쉬운 점
> 라파: 
> 
> 레오: 
> 
> 후니: 

> ## 앞으로의 계획
> 라파: 
> 
> 레오: 
> 
> 후니: 

<br>

[목차로 이동 🔺](#목차)

<br>

# 9주차
- 위클리 미션 실행화면 영상 업로드
- 스터디 미션 실행화면 영상 업로드

### 회고록
> ## 배운 점
> 라파: 
>
> 레오: 
>
> 후니: 

> ## 잘한 점
> 라파: 
> 
> 레오: 
> 
> 후니: 

> ## 아쉬운 점
> 라파: 
> 
> 레오: 
> 
> 후니: 

> ## 앞으로의 계획
> 라파: 
> 
> 레오: 
> 
> 후니: 

<br>

[목차로 이동 🔺](#목차)

<br>

# 10주차
- 위클리 미션 실행화면 영상 업로드
- 스터디 미션 실행화면 영상 업로드

### 회고록
> ## 배운 점
> 라파: 
>
> 레오: 
>
> 후니: 

> ## 잘한 점
> 라파: 
> 
> 레오: 
> 
> 후니: 

> ## 아쉬운 점
> 라파: 
> 
> 레오: 
> 
> 후니: 

> ## 앞으로의 계획
> 라파: 
> 
> 레오: 
> 
> 후니: 

<br>

[목차로 이동 🔺](#목차)

<br>

---

<br>

# Swift Style Guide
레오가 제안한 아이디어로 우리는 스터디 기간 동안 코드 컨벤션을 도입하려고 합니다. 
스터디 기간 동안 쓰이지 않을 것으로 판단되는 부분은 제외하고 아래 두 가지 출처에서 참고한 내용을 통합하여 사용할 것입니다.

 - [StyleShare](https://github.com/StyleShare/swift-style-guidehttps://github.com/StyleShare/swift-style-guide)
 - [토미의 개발노트](https://jusung.github.io/Swift-Code-Convention/)

이러한 코드 컨벤션 도입은 프로젝트의 코드 일관성과 가독성을 향상시키며 협업과 유지보수를 더욱 원활하게 만들 것입니다.

<br>

## Code Formatting

### [ import ]
> 모듈 임포트는 알파벳 순으로 정렬합니다. 
> 내장 프레임워크를 먼저 임포트하고, 빈 줄로 구분해 3rd-party 프레임워크를 임포트 합니다.

**✔️ Preferred**
```swift
import UIKit 
    
import SwiftyColor 
import SwiftyImage 
import Then 
import URLNavigator
```

**❌ Not Preferred**
```swift
import SwiftyColor 
import SwiftyImage 
import Then 
import UIKit 
import URLNavigator
```

<br>

> 파일이 필요로하는 최소의 모듈만 임포트 합니다. 예를들어, Foundation으로 충분하면 UIKit은 임포트 하지 않습니다.

**✔️ Preferred**
```swift
import UIKit 

var view: UIView 
var deviceModels: [String]
```
```swift
import Foundation 
var deviceModels: [String]
```

**❌ Not Preferred**
```swift
import UIKit 
import Foundation 

var view: UIView 
var deviceModels: [String]
```

<br>

[목차로 이동 🔺](#목차)

---

### [ 들여쓰기 및 띄어쓰기 ]
> 탭을 눌렀을 때 4개의 space를 사용합니다.

**✔️ Preferred**
```swift
class ViewController: UIViewController { 

	private lazy var scrollView: UIScrollView = { 
		let scrollView = UIScrollView() 
		return scrollView 
	}() 
	
}
```

**❌ Not Preferred**
```swift
class ViewController: UIViewController { 

  private lazy var scrollView: UIScrollView = { 
    let scrollView = UIScrollView() 
    return scrollView 
  }() 
	
}
```

<br>

> 콜론( : )을 쓸 때에는 콜론의 오른쪽에만 공백을 둡니다. 단, 삼항연산자의 경우에는 콜론 앞 뒤로 공백을 둡니다.

**✔️ Preferred**
```swift
class ViewController: UIViewController { 

	let names: [String: String]? 
	let someDictionary: [String: AnyObject] = [ 
		"Something 1": true, 
		"Something 2": false 
	] 

	func someFunction(a: String, b: String) { 
		// code 
	} 

} 

someFunction(a: "iNeptune", b: "Code Adventurers") 

extension ViewController: UITableViewDataSource { 
	// code 
}
```

```swift
let isHappy = true 
let feeling = isHappy ? "행복" : "불행"
```

**❌ Not Preferred**
```swift
class ViewController : UIViewController { 

	let names: [String : String]? 
	let someDictionary : [String : AnyObject] = [ 
		"Something 1" : true, 
		"Something 2" : false 
	] 

	func someFunction(a : String, b : String) { 
		// code 
	} 

} 

someFunction(a : "iNeptune", b : "Code Adventurers") 

extension ViewController : UITableViewDataSource { 
	// code 
}
```

```swift
let isHappy = true 
let feeling = isHappy ? "행복": "불행"
```

```swift
let names:[String:String]?
```

<br>

> 일반적으로 콤마(,) 뒤에는 공백을 추가합니다.

**✔️ Preferred**
```swift
let myArray = [1, 2, 3, 4, 5]
```

**❌ Not Preferred**
```swift
let myArray = [1,2,3,4,5]
```

<br>

> 연산자 앞뒤로 공백을 추가합니다.

**✔️ Preferred**
```swift
let myValue = 20 + (30 / 2) * 3
```

**❌ Not Preferred**
```swift
let myValue = 20+(30/2)*3
```

<br>

> 화살표 양쪽에 빈 공백을 추가합니다.

**✔️ Preferred**
```swift
func doSomething() -> String { 
	// ... 
}
```

```swift
func doSomething(completion: () -> Void) { 
	// ... 
}
```

**❌ Not Preferred**
```swift
func doSomething()->String { 
	// ... 
}
```

```swift
func doSomething(completion: ()->Void) { 
	// ... 
}
```

<br>

> 불필요한 괄호는 생략합니다.

**✔️ Preferred**
```swift
if userCount > 0 { ... } 
switch someValue { ... } 
let evens = userCounts.filter { number in number % 2 == 0 } 
let squares = userCounts.map { $0 * $0 }
```

**❌ Not Preferred**
```swift
if (userCount > 0) { ... } 
switch (someValue) { ... } 
let evens = userCounts.filter { (number) in number % 2 == 0 } 
let squares = userCounts.map() { $0 * $0 }
```

<br>

[목차로 이동 🔺](#목차)

---

### [ 줄바꿈 ]
> 클래스 블럭과 클래스 내부 코드 사이는 공백으로 구분합니다.

**✔️ Preferred**
```swift
class ViewController: UIViewController { 

	private lazy var scrollView: UIScrollView = { 
		let scrollView = UIScrollView() 
		return scrollView 
	}() 
	
}
```

**❌ Not Preferred**
```swift
class ViewController: UIViewController { 
	private lazy var scrollView: UIScrollView = { 
		let scrollView = UIScrollView() 
		return scrollView 
	}() 
}
```

<br> 

> 함수 정의가 최대 길이를 초과하는 경우에는 아래와 같이 줄바꿈합니다.

**✔️ Preferred**
```swift
func collectionView(
	_ collectionView: UICollectionView, 
	cellForItemAt indexPath: IndexPath 
) -> UICollectionViewCell { 
		// doSomething() 
} 

func animationController(
	forPresented presented: UIViewController, 
	presenting: UIViewController, 
	source: UIViewController 
) -> UIViewControllerAnimatedTransitioning? { 
	// doSomething() 
}
```

**❌ Not Preferred**
```swift
func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell { 
	// doSomething() 
} 

func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -> UIViewControllerAnimatedTransitioning? { 
	// doSomething() 
}
```

<br>

> 함수를 호출하는 코드가 최대 길이를 초과하는 경우에는 파라미터 이름을 기준으로 줄바꿈합니다. 단, 파라미터에 클로저가 2개 이상 존재하는 경우에는 무조건 내려쓰기합니다.

**✔️ Preferred**
```swift
let actionSheet = UIActionSheet(
	title: "정말 계정을 삭제하실 건가요?", 
	delegate: self, 
	cancelButtonTitle: "취소", 
	destructiveButtonTitle: "삭제해주세요"
)
```

```swift
UIView.animate(
	withDuration: 0.25, 
	animations: { 
		// doSomething() 
	}, 
	completion: { finished in 
		// doSomething() 
	} 
)
```

**❌ Not Preferred**
```swift
let actionSheet = UIActionSheet(title: "정말 계정을 삭제하실 건가요?", delegate: self, cancelButtonTitle: "취소", destructiveButtonTitle: "삭제해주세요")
```

<br>

> if let 구문이 길 경우에는 줄바꿈하고 한 칸 들여씁니다.

**✔️ Preferred**
```swift
if let user = self.veryLongFunctionNameWhichReturnsOptionalUser(), 
   let name = user.veryLongFunctionNameWhichReturnsOptionalName(), 
	   user.gender == .female { 
		   // ... 
}
```

**❌ Not Preferred**
```swift
if let user = self.veryLongFunctionNameWhichReturnsOptionalUser(), let name = user.veryLongFunctionNameWhichReturnsOptionalName(), user.gender == .female { 
	// ... 
}
```

<br>

> guard let 구문이 길 경우에는 줄바꿈하고 한 칸 들여씁니다. else는 guard와 같은 들여쓰기를 적용합니다.

**✔️ Preferred**
```swift
guard let user = self.veryLongFunctionNameWhichReturnsOptionalUser(),
      let name = user.veryLongFunctionNameWhichReturnsOptionalName(),
          user.gender == .female
else {
    return
}
```

**❌ Not Preferred**
```swift
guard let user = self.veryLongFunctionNameWhichReturnsOptionalUser(), let name = user.veryLongFunctionNameWhichReturnsOptionalName(), user.gender == .female else {
    return
}
```

<br>

[목차로 이동 🔺](#목차)

---

### [ 최대 줄 길이 ]
> 한 줄은 최대 120자를 넘지 않아야 합니다.

<br>

[목차로 이동 🔺](#목차)

---

##  Naming

### [ 클래스와 구조체 ]
> 클래스와 구조체의 이름에는 UpperCamelCase를 사용합니다.

**✔️ Preferred**
```swift
class SomeClass {
    // class definition goes here
}

struct SomeStructure {
    // structure definition goes here
}
```

**❌ Not Preferred**
```swift
class someClass {
    // class definition goes here
}

struct someStructure {
    // structure definition goes here
}
```

<br>

[목차로 이동 🔺](#목차)

---

### [ 함수 ]
> 함수 이름에는 lowerCamelCase를 사용합니다.

**✔️ Preferred**
```swift
func doSomething(a: String) -> String?
```

**❌ Not Preferred**
```swift
func DoSomething(b: String) -> String?
```

<br>

> 함수 이름에는 되도록  `get`을 붙이지 않습니다.

**✔️ Preferred**
```swift
func name(for user: User) -> String?
```

**❌ Not Preferred**
```swift
func getName(for user: User) -> String?
```

<br>

> ‘Tap(눌렀다 뗌)’은 UIControlEvents의 .touchUpInside에 대응하고, ‘Press(누름)’는 .touchDown에 대응합니다. 
> ’will’은 특정 행위가 일어나기 직전이고, ’did’는 특정 행위가 일어난 직후입니다. 
> ’should’는 일반적으로 Bool을 반환하는 함수에 사용됩니다.
>
> Action 함수의 네이밍은 '주어 + 동사 + 목적어' 형태를 사용합니다.

**✔️ Preferred**
```swift
func backButtonDidTap() {
    // ...
}
```

**❌ Not Preferred**
```swift
func back() {
    // ...
}

func pressBack() {
    // ...
}
```

<br>

[목차로 이동 🔺](#목차)

---

### [ 변수와 상수 ]
> 변수와 상수 이름에는 lowerCamelCase를 사용합니다.

**✔️ Preferred**
```swift
let maximumNumberOfLines = 3
```

**❌ Not Preferred**
```swift
let MaximumNumberOfLines = 3
let MAX_LINES = 3
```

<br>

[목차로 이동 🔺](#목차)

---

### [ 열거형 ]
> enum의 이름에는 UpperCamelCase를 사용하고 enum의 각 case에는 lowerCamelCase를 사용합니다.

**✔️ Preferred**
```swift
enum Result {
    case .success
    case .failure
}
```

**❌ Not Preferred**
```swift
enum Result {
    case .Success
    case .Failure
}

enum result {
    case .Success
    case .Failure
}
```

<br>

[목차로 이동 🔺](#목차)

---

### [ 프로토콜 ]
> 프로토콜의 이름에는 UpperCamelCase를 사용합니다. 
> 구조체나 클래스에서 프로토콜을 채택할 때는 콜론과 빈칸을 넣어 구분하여 명시합니다. 
> extension을 통해 채택할 때도 동일하게 적용됩니다.

**✔️ Preferred**
```swift
protocol SomeProtocol {
    // protocol definition goes here
}

struct SomeStructure: SomeProtocol, AnotherProtocol {
    // structure definition goes here
}

class SomeClass: SomeSuperclass, SomeProtocol, AnotherProtocol {
    // class definition goes here
}

extension UIViewController: SomeProtocol, AnotherProtocol {
    // doSomething()
}
```

**❌ Not Preferred**
```swift
protocol someProtocol {
    // protocol definition goes here
}

struct some_Structure:SomeProtocol, AnotherProtocol {
    // structure definition goes here
}

class Some_Class:SomeSuperclass, SomeProtocol, AnotherProtocol {
    // class definition goes here
}

extension UIViewController:SomeProtocol, AnotherProtocol {
    // doSomething()
}
```

<br>

[목차로 이동 🔺](#목차)

---

### [ 약어 ]
> 약어로 시작하는 경우 소문자로 표기하고, 그 외의 경우에는 항상 대문자로 표기합니다.

**✔️ Preferred**
```swift
let userID: Int?
let html: String?
let websiteURL: URL?
let urlString: String?
```

**❌ Not Preferred**
```swift
let userId: Int?
let HTML: String?
let websiteUrl: NSURL?
let URLString: String?
```

<br>

[목차로 이동 🔺](#목차)

---

### [ 일반 ]
> 일반적인 부분이 앞에두고 구체적인 부분을 뒤에 둡니다.

**✔️ Preferred**
```swift
let titleMarginRight: CGFloat
let titleMarginLeft: CGFloat
let bodyMarginRight: CGFloat
let bodyMarginLeft: CGFloat
```

**❌ Not Preferred**
```swift
let rightTitleMargin: CGFloat
let leftTitleMargin: CGFloat
let bodyRightMargin: CGFloat
let bodyLeftMargin: CGFloat
```

<br>

> 생략시 사용이 모호해지는 타입은 이름에 타입에 대한 힌트를 포함시킵니다.

**✔️ Preferred**
```swift
let titleText: String
let cancelButton: UIButton
```

**❌ Not Preferred**
```swift
let title: String
let cancel: UIButton
```

<br>

[목차로 이동 🔺](#목차)

---

##  Code Style

### [ 클로저 ]
> 파라미터와 리턴 타입이 없는 클로저 정의시에는 () -> Void 를 사용합니다.

**✔️ Preferred**
```swift
let completionBlock: (() -> Void)?
```

**❌ Not Preferred**
```swift
let completionBlock: (() -> ())?
let completionBlock: ((Void) -> (Void))?
```

<br>

> 클로저 정의시 파라미터에는 괄호를 사용하지 않습니다.

**✔️ Preferred**
```swift
{ operation, responseObject in
    // doSomething()
}
```

**❌ Not Preferred**
```swift
{ (operation, responseObject) in
    // doSomething()
}
```

<br>

> 클로저 정의시 가능한 경우 타입 정의를 생략합니다.

**✔️ Preferred**
```swift
completion: { finished in
    // doSomething()
}
```

**❌ Not Preferred**
```swift
completion: { (finished: Bool) -> Void in
    // doSomething()
}
```

<br>

> 클로저 호출시 또 다른 유일한 클로저를 마지막 파라미터로 받는 경우, 파라미터 이름을 생략합니다.

**✔️ Preferred**
```swift
UIView.animate(withDuration: 0.5) {
    // doSomething()
}
```

**❌ Not Preferred**
```swift
UIView.animate(withDuration: 0.5, animations: { () -> Void in
    // doSomething()
})
```

<br>

> 사용하지 않는 파라미터는 _를 사용해 표시합니다.

**✔️ Preferred**
```swift
someAsyncThing() { _, _, argument3 in
    print(argument3)
}
```

**❌ Not Preferred**
```swift
someAsyncThing() { argument1, argument2, argument3 in
    print(argument3)
}
```

<br>

> 한 줄 클로저는 반드시 각 괄호 양쪽을 공백을 추가해야 합니다.

**✔️ Preferred**
```swift
let evenSquares = numbers.filter { $0 % 2 == 0 }.map { $0 * $0 }
```

**❌ Not Preferred**
```swift
let evenSquares = numbers.filter {$0 % 2 == 0}.map { $0 * $0 }
```

<br>

[목차로 이동 🔺](#목차)

---

### [ 클래스와 구조체 ]
> 구조체를 생성할 때는 Swift 구조체 생성자를 사용합니다.

**✔️ Preferred**
```swift
let frame = CGRect(x: 0, y: 0, width: 100, height: 100)
```

**❌ Not Preferred**
```swift
let frame = CGRectMake(0, 0, 100, 100)
```

<br>

[목차로 이동 🔺](#목차)

---

### [ 타입 ]
> Array<T>와, Dictionary<T: U> 보다는 [T], [T: U]를 사용합니다.

**✔️ Preferred**
```swift
var messages: [String]?
var names: [Int: String]?
```

**❌ Not Preferred**
```swift
var messages: Array<String>?
var names: Dictionary<Int, String>?
```

<br>

[목차로 이동 🔺](#목차)

---

### [ 타입추론 사용 ]
> 컴파일러가 문맥속에서 타입을 추론할 수 있으면 더 간결한 코드를 위해 타입을 생략합니다.

**✔️ Preferred**
```swift
let selector = #selector(viewDidLoad)
view.backgroundColor = .red
let toView = context.view(forKey: .to)
let view = UIView(frame: .zero)
```

**❌ Not Preferred**
```swift
let selector = #selector(ViewController.viewDidLoad)
view.backgroundColor = UIColor.red
let toView = context.view(forKey: UITransitionContextViewKey.to)
let view = UIView(frame: CGRect.zero)
```

<br>

[목차로 이동 🔺](#목차)

---

### [ self ]
> 문법의 모호함을 제거하기 위해 언어에서 필수로 요구하지 않는 이상 self는 사용하지 않습니다.

**✔️ Preferred**
```swift
final class Listing {
    private let isFamilyFriendly: Bool
    private var capacity: Int
  
    init(capacity: Int, allowsPets: Bool) {
        ✅ Preferred 
        self.capacity = capacity
        isFamilyFriendly = !allowsPets
    }

    private func increaseCapacity(by amount: Int) {
        ✅ Preferred 
        capacity += amount

        ✅ Preferred 
        save()
    }
}
```

**❌ Not Preferred**
```swift
final class Listing {
    private let isFamilyFriendly: Bool
    private var capacity: Int
  
    init(capacity: Int, allowsPets: Bool) {
        ⛔️ Not Preferred 
        self.capacity = capacity
        self.isFamilyFriendly = !allowsPets
    }

    private func increaseCapacity(by amount: Int) {
        ⛔️ Not Preferred 
        self.capacity += amount

        ⛔️ Not Preferred 
        self.save()
  }
}
```

<br>

[목차로 이동 🔺](#목차)

---

### [ 튜플 ]
> 튜플의 맴버에는 명확성을 위해 이름을 붙여줍니다. 
> (만약 필드가 3개를 넘는 경우 struct를 사용을 고려해보는 것을 권장합니다.)

**✔️ Preferred**
```swift
func whatever() -> (x: Int, y: Int) {
    return (x: 4, y: 4)
}
```

**❌ Not Preferred**
```swift
func whatever() -> (Int, Int) {
    return (4, 4)
}
```

<br>

[목차로 이동 🔺](#목차)

---

### [ final ]
> 더 이상 상속이 발생하지 않는 클래스는 항상 final 키워드로 선언합니다.

**✔️ Preferred**
```swift
final class ViewController: UIViewController {
    // ...
}
```

**❌ Not Preferred**
```swift
class ViewController: UIViewController {
    // ...
}
```

<br>

[목차로 이동 🔺](#목차)

---

### [ 프로토콜 extension ]
> 프로토콜을 적용할 때는 extension을 만들어서 관련된 매소드를 모아둡니다.

**✔️ Preferred**
```swift
final class MyViewController: UIViewController {
    // ...
}
extension MyViewController: UITableViewDataSource {
    // ...
}
extension MyViewController: UITableViewDelegate {
    // ...
}
```

**❌ Not Preferred**
```swift
final class MyViewController: UIViewController, UITableViewDataSource, UITableViewDelegate {
    // ...
}
```

<br>

> 생략시 사용이 모호해지는 타입은 이름에 타입에 대한 힌트를 포함시킵니다.

**✔️ Preferred**
```swift
let titleText: String
let cancelButton: UIButton
```

**❌ Not Preferred**
```swift
let title: String
let cancel: UIButton
```

<br>

[목차로 이동 🔺](#목차)

---

### [ 사용하지 않는 코드 ]
> Xcode가 자동으로 생성한 템플릿을 포함한 사용하지 않는 코드는 placeholder 코멘트를 포함해 모두 제거합니다.

**✔️ Preferred**
```swift
override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
    return Database.contacts.count
}
```

**❌ Not Preferred**
```swift
override func didReceiveMemoryWarning() {
  super.didReceiveMemoryWarning()
  // Dispose of any resources that can be recreated.
}

override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
  // #warning Incomplete implementation, return the number of rows
  return Database.contacts.count
}
```

<br>

[목차로 이동 🔺](#목차)

---

### [ 주석 ]
> ///를 사용해서 문서화에 사용되는 주석을 남깁니다.

**✔️ Preferred**
```swift
/// 사용자 프로필을 그려주는 뷰
class ProfileView: UIView {

    /// 사용자 닉네임을 그려주는 라벨
    var nameLabel: UILabel!
}
```

**❌ Not Preferred**
```swift
// 사용자 프로필을 그려주는 뷰
class ProfileView: UIView {

    // 사용자 닉네임을 그려주는 라벨
    var nameLabel: UILabel!
}
```

<br>

> // MARK:를 사용해서 연관된 코드를 구분짓습니다. (MARK 구문 위와 아래에는 공백이 필요합니다.)

**✔️ Preferred**
```swift
// MARK: Init

override init(frame: CGRect) {
    // doSomething()
}

deinit {
    // doSomething()
}


// MARK: Layout

override func layoutSubviews() {
    // doSomething()
}


// MARK: Actions

override func menuButtonDidTap() {
    // doSomething()
}
```

**❌ Not Preferred**
```swift
// MARK: Init
override init(frame: CGRect) {
    // doSomething()
}

deinit {
    // doSomething()
}

// MARK: Layout
override func layoutSubviews() {
    // doSomething()
}

// MARK: Actions
override func menuButtonDidTap() {
    // doSomething()
}
```
